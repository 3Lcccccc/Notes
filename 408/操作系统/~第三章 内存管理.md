# 3.1 内存管理概念
## 3.1.1 内存管理的基本原理和要求

**内存管理的功能**
1. 内存空间的分配与回收
2. 地址转换
3. 内存空间的扩充
4. 存储保护


***
### 1.程序装入和链接
1. 编译
2. 链接
   - 由链接程序将编译后形成的一组目标模块以及所需的库函数链接在一起，形成一个完整的装入模块。
3. 装入
- 链接的三种方式
   1. 静态链接
   2. 装入时动态链接
   3. 运行时动态链接
- 装入的三种方式
   1. 绝对装入(还没有操作系统)
   2. 可重定位装入(早期批处理操作系统)
      1. 装入时更改指令的地址
      2. 特点：装入时必须分配它要求的全部内存，若没有足够内存则不能装入。
   3. 动态运行时装入(现代操作系统)
      1. 全部为相对地址
      2. 特点：需要重定位寄存器
***
### 2.内存保护
让各个进程自己访问自己的内存空间
内存保护的两种方法
1. 设置上下限寄存器
2. 采用重定位寄存器和界地址寄存器(逻辑地址的上限)又称基址和限长寄存器

## 3.1.2 连续分配管理方式
1. 单一连续分配
   1. 内存被分为系统区(通常位于低地址)和用户区
   2. 内存中只能有一道程序，用户程序独占整个用户区
   3. 👍优点：实现简单、无外部碎片、可以采用覆盖技术扩充内存、不一定需要采取内存保护
   4. 👎缺点：只能用于单用户、单任务的操作系统中、有内部碎片、存储器利用率极低。
2. 固定分区分配
   1. 将用户区分成若干分区，每个分区只能装入一道作业
   2. 分区大小相等
      - 缺乏灵活性，但是很适用于用一台计算机控制多个相同对象的场合
   3. 分区大小不等
      1. 增加了灵活性，可以满足不同大小的进程需求
   4. 需要建立一个分区说明表来记录分区的大小、起始地址、状态
   5. 👍优点：实现简单、无外部碎片
   6. 👎缺点：
      1. 当用户程序太大时，可能所有的分区都不能满足，此时不得不采用覆盖技术来解决，但又会降低性能
      2. 会产生内部碎片，内存利用率低
3. 动态分区分配
   1. 在进程装入内存时根据进程的大小动态地建立分区
   2. 采用空闲分区表或链来记录分区信息
   3. 没有内部碎片，但是有外部碎片

内部碎片：分配给某进程的内存区域中，如果有些部分没有用上。
外部碎片：是指内存中的某些空闲分区由于大小而难以利用。

***

**动态分区分配算法**
1. 首次适应(FF)
   - 每次都从低地子开始查找，找到第一个能满足大小的空闲分区
2. 最佳适应(BF)
   - 优先使用小的空闲分区
   - 空闲分区按照容量递增排序
   - 👎缺点：每次都选最小的分区进行分配，会留下越来越多的、很小的、难已利用的内存块。因此这种方法会产生很多的外部碎片。
3. 最坏适应(WF)
   - 优先利用最大的空闲分区
   - 👎缺点：每次都选最大的分区进行分配，会导致较大的连续空闲区被迅速用完。之后又大进程到达，就没有内存分区可用了。
4. 邻近适应(NF)
   - 每一次查找都是从上次结束的位置开始
   - 👎缺点：高地址的大分区也会被用完

## 3.1.3 非连续分配管理方式
1. **基本分页存储管理方式**
   1. 基本概念
      1. 将内存空间分成一个个大小相等的分区，每个分区就是一个页框(页桢、内存块、物理块、物理页面)，每个页框有一个编号，即页框号(从0开始)。
      2. 将进程的逻辑地址空间页分为与页框大小相等的一个个部分，每一个部分称为一个页(页面)。每个页面也有一个编号，即页号(从0开始)。
      3. 各个页面不必连续存储。
      4. **页表**
         1. 一个进程对应一个页表
         2. 进程中的每个页面对应一个页表项
         3. 每个页表项由页号和块号组成
         4. 页表通常储存在PCB中
         5. 页号是不需要占存储空间的因为页表项是连续存放的
         6.  **如果有$k$位表示"页内偏移量"，则说明该系统中一个页面的大小是$2^k$个内存单元**
         7.  **如果有$m$位表示"页号"，则说明该系统中，一个进程最多有$2^m$个页面。**
   2. 基本地址变化机构
      1. 计算页号和页内偏移量的值
      2. 比较页号和页表长度判断是否越界
      3. 根据页号取出页框号
      4. 计算物理地址
   3. 具有快表的地址变化机构
      1. 快表(又称联想寄存器 TLB)
         1. 一种访问速度**比内存快很多**的高速缓存(**不是内存**)，用来存放最近访问的页表项副本。
      2. 优先查询快表
      3. 如果快表没有命中再查询慢表并且把表项复制到快表中
   4. 两级页表
      1. 把页表分成n等份，再利用一个新的**页目录表**来记录这些小页表
      2. 若采用多级页表机制，则各级页表的大小不能超过一个页面
2. **基本分段存储法管理方式**
   1. 分段
      1. 进程的地址空间
         - 按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名，每段从0开始编址
      2. 内存分配规则
         - 以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻。
      3. 分段系统的逻辑地址结构由段号和段内地址锁组成
      4. 编译器会将段名转换成段号
   2. 段表
      1. 起始位置和段的长度
3. **分段与分页管理的对比**
   1. 页是信息的物理单位，**分页的主要目的是为了实现离散分配，提高内存利用率。仅仅是系统管理上的需要**，完全是系统行为，对用户是不可见的。
   2. 段是信息的逻辑单位，**分段的主要目的是为了更好地满足用户需求**。对用户是可见的，用户编程时需要显式地给出段名。
   3. 分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址
   4. 分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段长，也要给出段内地址
   5. 分段比分页更容易实现共享和分页
4. **段页式管理**
   1. 分页管理
      1. 👍优点：
         - 内存空间利用率高，不会产生外部碎片，只会有少量的页内碎片
      2. 👎缺点：
         - 不方便按照逻辑模块实现信息的共享和保护
   2. 分段管理
      1. 👍优点：
         - 很方便按照逻辑模块实现信息的共享和保护
      2. 👎缺点：
         - 如果段长过大，为其分配很大的连续空间会很不方便。还会产生外部碎片
   3. 段页式管理
      1. 先分段在分页
      2. 先读段表获取页表地址，再读页表获得内存块号

# 3.2.1 虚拟内存的基本概念

## 1.传统存储管理方式的特征、缺点

1. 一次性：作业必须一次性全部装入内存后才嫩开始运行
   1. 会带来两个问题
      1. 作业很大时不能全部装入内存
      2. 有大量作业时，内存无法全部装下，导致并发度下降
2. 驻留性：一旦作业被装入内存。就会一直驻留在内存中，直至作业运行结束。
   
## 2. 虚拟内存的定义和特征

1. 多次性：允许作业被分成多次调入
2. 对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。
3. 虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。

# 3.2.2 请求分页管理方式

**与基本分页管理相比增加的功能：**
1. 请求调页：当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存
2. 页面置换：若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存

## 1. 页表机制

**页表新增的四个字段：**
1. 状态位P:是否调入内存
2. 访问字段A：记录访问信息
3. 修改位M：页面调入内存后是否被修改过
4. 外存地址：

## 2. 缺页中断机构

$\qquad$每当要访问的页面不在内存时，便产生一个缺页中断，然后由操作系统的缺页中断处理程序处理中断。此时缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列。

如果内存中有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中 相应的页表项。

如果内存中没有空闲块，则由页面置换算法选择一个页面淘汰，若该页面在内存期间被修改过，则将其写回外存。

# 3.2.3 置换算法

1. 最佳(OPT)
   1. 思想：每次选择**淘汰的页面**将是**以后永不使用**，或者在**最长时间内不被在访问的页面**
   2. 实现方法：理想化的算法，实际中是无法实现的(无法提前知道那些会被访问)
2. 先进先出(FIFO)
   1. 思想：每次**淘汰最先进入内存的页面**
   2. 实现方法：把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面是选择对头页面即可，队列的最大长度取决于进程被分配的内存块
   3. 会产生Belady异常(增加内存块缺页次不减反增)
   4. 实现简单，性能差
3. 最近未被使用(LRU)
   1. 思想：每次淘汰的页面是最近最久未使用的页面
   2. 实现方法：利用修改位记录
   3. 实现困难，开销大，性能好
4. 时钟(CLOCK)最近未被使用(NRU)
   1. 实现方法：将内存中的页面通过链接指针**链接成一个循环队列**。页面被访问时，访问位为1，当需要淘汰一个页面时，只需检测页的访问位。如果是0，就选择该页换出；如果是1，则将它变成0，继续检测下个页面。
   2. 实现简单，开销下，但未考虑页面是否被修改
5. 改进型时钟
   1. 思想：优先淘汰未被修改与未被访问的页面
   2. 实现方法：(0,0)本轮扫描不修改任何标志位$\rightarrow$(0,1)访问修改为0$\rightarrow$(0,0)本轮扫描不修改任何标志位$\rightarrow$(0,1)
   3. 开销下，性能不错