# 排序

## 插入排序

- 直接插入排序
  - 时间复杂度：$O(n^2)$
- 折半插入排序
  - 先利用折半查找来查找插入的位置
  - 再统一移动元素的位置
  - 时间复杂度：$O(n^2)$
- 希尔排序
  - 先将整个序列根据增量$d[i,i+d,i+2d,\cdots ]$划分为多个子表
  - 对每个子表进行直接插入排序
  - 重复直至对整个表进行插入排序
  - 时间复杂度：$O(n^2)$ 有序时为$O(n)$

## 交换排序

- 冒泡排序
  - 时间复杂度：$O(n^2)$
- 快速排序
  - 每一趟选择一个元素作为枢轴,将比枢轴小的元素放在其左边,大的元素放在右边
  - 每一趟都会将枢轴放在最终的位置上
  - 时间复杂度：$O(nlog_2n)$
  - 空间复杂度$O(log_2n)$
  - 每次把表划分为相等长度时是最快的
  - 👍内部排序中平均性能最优的算法

## 选择排序

- 简单选择排序
  - 第$i$趟排序,从$L[i\cdots n]$中选择最小的元素与$L[i]$交换
  - 与初始序列无关
  - 时间复杂度为：$O(n^2)$
- 堆排序
  - 将一维数组视为完全二叉树
  - 堆是具有以下性质的完全二叉树：
    - 大根堆：每个结点的值都大于或等于其左右孩子结点的值
    - 小根堆：或者每个结点的值都小于或等于其左右孩子结点的值
  - 思想：
    - 初始化堆
      - 从最后一个非叶子结点开始$\left\lfloor\frac{n}{2}\right\rfloor$
      - 依次对比是否大于(小于)孩子结点
      - 交换后可能会破坏下一级堆,需要重新构造下一级堆
      - 重复直到根节点
    - 排序
      - 将堆顶元素于末端元素交换,得到最大值
      - 调整堆,忽视之前交换的堆顶元素
      - 重复直至全部元素都到达过堆顶
    - 插入
      - 先将元素放在堆的末端,在与双亲结点对比进行向上调整
      - 重复
    - 时间复杂度：$O(nlog_2n)$

## 归并和基数排序

- 归并排序
  - 思想：
    - 将长度为为$n$的表看成$n$个子表
    - 将相连的子表合并
    - 重复直到合并成一个子表
  - 时间复杂度：$O(nlog_2n)$
- 基数排序
  - 基于各位的大小排序

## 总结

- 只需得到前$k$项的顺序排序
  - 冒泡、堆、简单选择排序