# 树

## 存储结构

- 树
  - 双亲表示法
    - 利用二维数组存储每一行存放数据与伪指针,伪指针存放双亲的数组下标
    - 找双亲
  - 孩子表示法
    - 利用二维数组存储,每一行存放数据和指针指向由孩子结点组成的链表
    - 找孩子
  - 孩子兄弟表示法(二叉树表示法)
    - 利用二叉链表,每个结点中存储：结点值、指向第一个孩子、下一个兄弟
    - 找孩子
- 二叉树
  - 数组
    - 满二叉树的形式存储空结点也占用存储空间，顺序类似层次遍历
  - 二叉链表
  - 二叉树可以使用树的存储方式,但是树不可以使用二叉树的存储方式

## 特殊的二叉树

- 满二叉树
- 完全二叉树
  - 当$n>1$时，结点$i$的双亲的编号为$\lfloor\frac{i}{2}\rfloor$,当$i$为偶数时，它是双亲的左孩子，为奇数时是双亲的右孩子
  - 当$2i \leq n$时，结点$i$的左孩子编号为$2i$，否则无左孩子。
  - 结点$i$所在的层次为$\lfloor\log_2i\rfloor$
  - 具有n个结点的完全二叉树的高度为$\lceil\log_2(n+1)\rceil$或$\lfloor\log_2i\rfloor$+1
- 线索二叉树
  - 利用空指针来指向前驱或后继
  - 增加了`ltag`,`rtag`指针
  - `tag==0`指向孩子,`tag==1`指向前驱后继
  - 后序线索二叉树不能有效解决求后序后继的问题
- 🌟二叉排序树
  - 左子树小于根节点，右子树大于根节点
  - 中序遍历可以得到递增序列
  - 是一种动态树表
  - 只有单支树时(链表)查找长度为$O(n)$
- 🌟平衡二叉树(AVL)
  - 在排序树的条件下左子树右子树深度之差不超过$1$
  - 查找长度为$O(\log_2n)$
- 🌟🌟哈夫曼树
  - 带权路径长度最小的树
  - 带权路径=到每个结点的长度$\times$该结点的权值

## 二叉树的性质

- 非空二叉树的叶子结点等于为2的结点数加1，即$n_0=n_2+1$
- 非空二叉树上第$k$层至多有$2^{k-1}$个结点
- 高度为h的二叉树至多有$2^h-1$个结点
  
 
## 遍历

### 二叉树的遍历
- 先序遍历
- 中序遍历
- 后序遍历
  - 找根
- 层次遍历
  - 找叶子结点、高度
- 中序+任意都可以确定一颗树
- 先序和后序相反$\rightleftarrows$每层只有一个结点
- 二叉排序树使用非递归更好

### 树和森林的遍历

- 树
  - 先根遍历=先序遍历
  - 后根遍历=中序遍历
- 森林
  - 先序遍历
  - 中序遍历
## 转换

- 树$\rightarrow$二叉树
  - 每个结点左指针指向它的第一个孩子,右指针指向相邻的右兄弟
  - 根节点没有兄弟所以对应的二叉树没有右孩子，每个分支结点中最右结点无右孩子
  - 对应二叉树中**无右孩子的结点个数$=$分支结点树$+1$**
- 森林$\rightarrow$二叉树
  - 将每颗树转换成二叉树,再把根结点视为兄弟连接
- 二叉树$\rightarrow$森林
  - 左孩子右兄弟
  - 每个二叉树对应唯一的森林

## 应用 🛠️

- 求树的高度
  - 使用层次遍历
- 非递归遍历树时使用栈或队列辅助
- 二叉排序树
  - 插入
    - 先查找到合适的结点
  - 删除
    - 先判断有几个孩子
    - 有多个孩子的话让其后继成为结点
- 平衡二叉树
  - LL旋转(右旋)
    - 在左孩子的左结点插入新结点导致的失衡
    - A的左孩子B成为新根,A为B的右子树,B原来的右子树为A的左子树
  - RR旋转(左旋)
    - 在右孩子的右结点插入新结点导致的失衡
     - A的右孩子B成为新根,A为B的左子树,B原来的左子树为A的右子树
  - LR旋转(先左后右)
    - 在左孩子的右结点插入新结点导致的失衡
    - 先将A的**左孩子**B的**右孩子**C左旋代替B,成为A的左孩子
    - 再将C**右旋**代替A成为根节点
  - RL旋转(先左后右)
    - 在右孩子的左结点插入新结点导致的失衡
    - 先将A的**右孩子**B的**左孩子**C右旋代替B,成为A的右孩子
    - 再将C**左旋**代替A成为根节点
  - A(最小不平衡树的原根)
- 哈夫曼树
  - 构造
    - 将n个结点看成森林
    - 构造一个新结点,权值最小的两个结点为其孩子
    - 新结点的权值为孩子的合
    - 重复至只剩一棵树
  - 特点
    - 每个最初的结点都成为了叶子结点
    - 权值最小的结点到根节点的路径长度越大
    - 构造过程中产生了`n-1`个结点,哈夫曼树的总结点为`2n-1`
    - 不存在度为`1`的结点
- 编码
  - 前缀编码
    - 没有一个编码是另一个编码的前缀
  - 哈夫曼编码
    - 由哈夫曼树构成的编码
    - 左子树代表0,右子树代表1
    - 权值越大编码长度越小